diff -rupN a/include/openssl/ssl.h b/include/openssl/ssl.h
--- a/include/openssl/ssl.h	2016-07-04 14:12:38.000000000 +0930
+++ b/include/openssl/ssl.h	2016-07-04 15:31:19.000474508 +0930
@@ -1804,7 +1804,10 @@ OPENSSL_EXPORT int SSL_CTX_set_tlsext_ti
  * In both modes, |ctx| and |hmac_ctx| will already have been initialized with
  * |EVP_CIPHER_CTX_init| and |HMAC_CTX_init|, respectively. |callback|
  * configures |hmac_ctx| with an HMAC digest and key, and configures |ctx|
- * for encryption or decryption, based on the mode.
+ * for encryption or decryption, based on the mode. If |callback| returns
+ * TLSEXT_TICKET_CB_WANT_AEAD then |callback| will be called a second time
+ * with |ctx| set to a |EVP_AEAD_CTX|* on which |EVP_AEAD_CTX_zero| has been
+ * called, and |hmac_ctx| will be set to |SSL_magic_tlsext_ticket_key_cb_aead_ptr|.
  *
  * When encrypting a new ticket, |encrypt| will be one. It writes a public
  * 16-byte key name to |key_name| and a fresh IV to |iv|. The output IV length
@@ -1824,6 +1827,17 @@ OPENSSL_EXPORT int SSL_CTX_set_tlsext_ti
     SSL_CTX *ctx, int (*callback)(SSL *ssl, uint8_t *key_name, uint8_t *iv,
                                   EVP_CIPHER_CTX *ctx, HMAC_CTX *hmac_ctx,
                                   int encrypt));
+ 
+/* SSL_magic_tlsext_ticket_key_cb_aead_ptr returns a magic |HMAC_CTX|* which
+ * indicates that the |ctx| variable passed into |callback| is not
+ * a |EVP_CIPHER_CTX|* but is instead a |EVP_AEAD_CTX|*. */
+OPENSSL_EXPORT HMAC_CTX *SSL_magic_tlsext_ticket_key_cb_aead_ptr(void);
+
+/* The return value of the ticket callback that requests AEAD operation.
+ *
+ * See |SSL_CTX_set_tlsext_ticket_key_cb|
+ * and |SSL_magic_tlsext_ticket_key_cb_aead_ptr|. */
+#define TLSEXT_TICKET_CB_WANT_AEAD -0xAEAD
 
 
 /* Elliptic curve Diffie-Hellman.
diff -rupN a/ssl/handshake_server.c b/ssl/handshake_server.c
--- a/ssl/handshake_server.c	2016-07-04 14:12:38.000000000 +0930
+++ b/ssl/handshake_server.c	2016-07-04 15:54:48.536452636 +0930
@@ -2134,8 +2134,10 @@ static int ssl3_send_new_session_ticket(
   EVP_CIPHER_CTX_init(&ctx);
   HMAC_CTX hctx;
   HMAC_CTX_init(&hctx);
+  EVP_AEAD_CTX aead_ctx;
+  EVP_AEAD_CTX_zero(&aead_ctx);
 
-  int ret = -1;
+  int ret = -1, is_aead = 0;
   CBB cbb, body, ticket;
   if (!ssl->method->init_message(ssl, &cbb, &body, SSL3_MT_NEW_SESSION_TICKET) ||
       /* Ticket lifetime hint (advisory only): We leave this unspecified for
@@ -2148,8 +2150,11 @@ static int ssl3_send_new_session_ticket(
 
   /* If the session is too long, emit a dummy value rather than abort the
    * connection. */
-  const size_t max_ticket_overhead =
-      16 + EVP_MAX_IV_LENGTH + EVP_MAX_BLOCK_LENGTH + EVP_MAX_MD_SIZE;
+  const size_t max_ticket_overhead = 16 +
+      (EVP_MAX_IV_LENGTH < EVP_AEAD_MAX_NONCE_LENGTH
+          ? EVP_AEAD_MAX_NONCE_LENGTH : EVP_MAX_IV_LENGTH) +
+      ((EVP_MAX_BLOCK_LENGTH + EVP_MAX_MD_SIZE) < EVP_AEAD_MAX_OVERHEAD
+          ? EVP_AEAD_MAX_OVERHEAD : EVP_MAX_BLOCK_LENGTH + EVP_MAX_MD_SIZE);
   if (session_len > 0xffff - max_ticket_overhead) {
     static const char kTicketPlaceholder[] = "TICKET TOO LARGE";
 
@@ -2167,11 +2172,20 @@ static int ssl3_send_new_session_ticket(
   /* Initialize HMAC and cipher contexts. If callback present it does all the
    * work otherwise use generated values from parent ctx. */
   SSL_CTX *tctx = ssl->initial_ctx;
-  uint8_t iv[EVP_MAX_IV_LENGTH];
+  uint8_t iv[EVP_MAX_IV_LENGTH < EVP_AEAD_MAX_NONCE_LENGTH ? EVP_AEAD_MAX_NONCE_LENGTH : EVP_MAX_IV_LENGTH];
   uint8_t key_name[16];
   if (tctx->tlsext_ticket_key_cb != NULL) {
-    if (tctx->tlsext_ticket_key_cb(ssl, key_name, iv, &ctx, &hctx,
-                                   1 /* encrypt */) < 0) {
+    int cb_ret = tctx->tlsext_ticket_key_cb(ssl, key_name, iv, &ctx, &hctx,
+                                            1 /* encrypt */);
+    if (cb_ret == TLSEXT_TICKET_CB_WANT_AEAD) {
+      is_aead = 1;
+
+      cb_ret = tctx->tlsext_ticket_key_cb(ssl, key_name, iv,
+                                          (EVP_CIPHER_CTX *)&aead_ctx,
+                                          SSL_magic_tlsext_ticket_key_cb_aead_ptr(),
+                                          1 /* encrypt */);
+    }
+    if (cb_ret < 0) {
       goto err;
     }
   } else {
@@ -2186,8 +2200,28 @@ static int ssl3_send_new_session_ticket(
   }
 
   uint8_t *ptr;
-  if (!CBB_add_bytes(&ticket, key_name, 16) ||
-      !CBB_add_bytes(&ticket, iv, EVP_CIPHER_CTX_iv_length(&ctx)) ||
+  if (!CBB_add_bytes(&ticket, key_name, 16)) {
+    goto err;
+  }
+
+  if (is_aead) {
+    size_t out_len;
+    const size_t nonce_len = EVP_AEAD_nonce_length(aead_ctx.aead);
+    const size_t max_overhead = EVP_AEAD_max_overhead(aead_ctx.aead);
+
+    if (!CBB_add_bytes(&ticket, iv, nonce_len) ||
+        !CBB_reserve(&ticket, &ptr, session_len + max_overhead) ||
+        !EVP_AEAD_CTX_seal(&aead_ctx,
+                           ptr, &out_len, session_len + max_overhead,
+                           iv, nonce_len, session, session_len, NULL, 0) ||
+        !CBB_did_write(&ticket, out_len)) {
+       goto err;
+    }
+
+    goto done;
+  }
+
+  if (!CBB_add_bytes(&ticket, iv, EVP_CIPHER_CTX_iv_length(&ctx)) ||
       !CBB_reserve(&ticket, &ptr, session_len + EVP_MAX_BLOCK_LENGTH)) {
     goto err;
   }
@@ -2210,8 +2244,12 @@ static int ssl3_send_new_session_ticket(
   if (!HMAC_Update(&hctx, CBB_data(&ticket), CBB_len(&ticket)) ||
       !CBB_reserve(&ticket, &ptr, EVP_MAX_MD_SIZE) ||
       !HMAC_Final(&hctx, ptr, &hlen) ||
-      !CBB_did_write(&ticket, hlen) ||
-      !ssl->method->finish_message(ssl, &cbb)) {
+      !CBB_did_write(&ticket, hlen)) {
+    goto err;
+  }
+
+done:
+  if (!ssl->method->finish_message(ssl, &cbb)) {
     goto err;
   }
 
@@ -2220,6 +2258,7 @@ static int ssl3_send_new_session_ticket(
 
 err:
   OPENSSL_free(session);
+  EVP_AEAD_CTX_cleanup(&aead_ctx);
   EVP_CIPHER_CTX_cleanup(&ctx);
   HMAC_CTX_cleanup(&hctx);
   return ret;
diff -rupN a/ssl/ssl_lib.c b/ssl/ssl_lib.c
--- a/ssl/ssl_lib.c	2016-07-04 14:12:38.000000000 +0930
+++ b/ssl/ssl_lib.c	2016-07-04 15:32:06.016473779 +0930
@@ -156,6 +156,11 @@
 #include "../crypto/internal.h"
 
 
+/* The address of this is a magic value, a pointer to which is returned by
+ * SSL_magic_tlsext_ticket_key_cb_aead_ptr(). It indicated that AEAD mode is
+ * being used. */
+static const char g_tlsext_ticket_cb_aead_magic = 0;
+
 /* |SSL_R_UNKNOWN_PROTOCOL| is no longer emitted, but continue to define it
  * to avoid downstream churn. */
 OPENSSL_DECLARE_ERROR_REASON(SSL, UNKNOWN_PROTOCOL)
@@ -1338,6 +1343,10 @@ int SSL_CTX_set_tlsext_ticket_key_cb(
   return 1;
 }
 
+HMAC_CTX *SSL_magic_tlsext_ticket_key_cb_aead_ptr(void) {
+  return (HMAC_CTX *)&g_tlsext_ticket_cb_aead_magic;
+}
+
 int SSL_CTX_set1_curves(SSL_CTX *ctx, const int *curves, size_t curves_len) {
   return tls1_set_curves(&ctx->supported_group_list,
                          &ctx->supported_group_list_len, curves,
diff -rupN a/ssl/t1_lib.c b/ssl/t1_lib.c
--- a/ssl/t1_lib.c	2016-07-04 14:12:38.000000000 +0930
+++ b/ssl/t1_lib.c	2016-07-04 15:47:06.288459809 +0930
@@ -2411,6 +2411,7 @@ int tls_process_ticket(SSL *ssl, SSL_SES
                        size_t ticket_len, const uint8_t *session_id,
                        size_t session_id_len) {
   int ret = 1; /* Most errors are non-fatal. */
+  int is_aead = 0;
   SSL_CTX *ssl_ctx = ssl->initial_ctx;
   uint8_t *plaintext = NULL;
 
@@ -2418,6 +2419,8 @@ int tls_process_ticket(SSL *ssl, SSL_SES
   HMAC_CTX_init(&hmac_ctx);
   EVP_CIPHER_CTX cipher_ctx;
   EVP_CIPHER_CTX_init(&cipher_ctx);
+  EVP_AEAD_CTX aead_ctx;
+  EVP_AEAD_CTX_zero(&aead_ctx);
 
   *out_renew_ticket = 0;
   *out_session = NULL;
@@ -2439,6 +2442,14 @@ int tls_process_ticket(SSL *ssl, SSL_SES
     int cb_ret = ssl_ctx->tlsext_ticket_key_cb(
         ssl, (uint8_t *)ticket /* name */, (uint8_t *)iv, &cipher_ctx,
         &hmac_ctx, 0 /* decrypt */);
+    if (cb_ret == TLSEXT_TICKET_CB_WANT_AEAD) {
+      is_aead = 1;
+
+      cb_ret = ssl_ctx->tlsext_ticket_key_cb(
+          ssl, (uint8_t *)ticket /* name */, (uint8_t *)iv,
+          (EVP_CIPHER_CTX *)&aead_ctx, SSL_magic_tlsext_ticket_key_cb_aead_ptr(),
+          0 /* decrypt */);
+    }
     if (cb_ret < 0) {
       ret = 0;
       goto done;
@@ -2464,6 +2475,44 @@ int tls_process_ticket(SSL *ssl, SSL_SES
       goto done;
     }
   }
+
+  if (is_aead) {
+    const size_t nonce_len = EVP_AEAD_nonce_length(aead_ctx.aead);
+
+    /* Decrypt the session data. */
+    const uint8_t *ciphertext = ticket + SSL_TICKET_KEY_NAME_LEN + nonce_len;
+    size_t ciphertext_len = ticket_len - SSL_TICKET_KEY_NAME_LEN - nonce_len;
+    plaintext = OPENSSL_malloc(ciphertext_len);
+    if (plaintext == NULL) {
+      ret = 0;
+      goto done;
+    }
+
+    size_t plaintext_len;
+
+    if (!EVP_AEAD_CTX_open(&aead_ctx, plaintext, &plaintext_len, ciphertext_len,
+                           iv, nonce_len, ciphertext, ciphertext_len, NULL, 0)) {
+      ERR_clear_error(); /* Don't leave an error on the queue. */
+      goto done;
+    }
+
+    /* Decode the session. */
+    SSL_SESSION *session = SSL_SESSION_from_bytes(plaintext, plaintext_len);
+    if (session == NULL) {
+      ERR_clear_error(); /* Don't leave an error on the queue. */
+      goto done;
+    }
+
+    /* Copy the client's session ID into the new session, to denote the ticket has
+     * been accepted. */
+    memcpy(session->session_id, session_id, session_id_len);
+    session->session_id_length = session_id_len;
+
+    *out_session = session;
+
+    goto done;
+  }
+
   size_t iv_len = EVP_CIPHER_CTX_iv_length(&cipher_ctx);
 
   /* Check the MAC at the end of the ticket. */
@@ -2517,6 +2566,7 @@ done:
   OPENSSL_free(plaintext);
   HMAC_CTX_cleanup(&hmac_ctx);
   EVP_CIPHER_CTX_cleanup(&cipher_ctx);
+  EVP_AEAD_CTX_cleanup(&aead_ctx);
   return ret;
 }
 
